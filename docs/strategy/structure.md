# Общая структура стратегий.

Торговая стратегия получает на вход информацию об изменениях, произошедших с какими-то инструментами[] на бирже. В зависимости от этой информации стратегия совершает какие-то действия – это может быть постановка новых заявок и/или запрос на удаление старых. При этом на каких-то инструментах стратегия осуществляет торговлю (соответстующие названия будут содержать *trade*), а по каким-то инструментам только получает информацию, чтобы использовать ее для торговли на других (соответствующие названия будут содержать *feed*). Далее считаем, что есть ровно один *trade*-инструмент и не более одного *feed*-инструмента.

Рассмотрим класс-шаблон **UserStrategy** для стратегий:
```cpp
#include "strategy/participant_strategy_layer.h"

using namespace xor_platform;
using namespace contest_platform;

// Это основной класс, в котором пользователь реализует свою стратегию.
class UserStrategy : public ParticipantStrategy {
public:
  /**
   * Вызывается при получении нового стакана инструмента, на котором мы торгуем:
   * order_book – новый стакан.
   **/
  virtual void book_trade_update(const OrderBook& order_book) {
    /* написать свою реализацию здесь */
  }

  /**
   * Вызывается при получении нового стакана инструмента, на который мы смотрим:
   * order_book – новый стакан.
   **/
  virtual void book_feed_update(const OrderBook& order_book) {
    /* написать свою реализацию здесь */
  }

  /**
   * Вызывается при получении новых сделок инструмента, на котором мы торгуем:
   * trades - вектор новых сделок.
   **/
  virtual void trades_trade_update(const std::vector<Trade>& trades) {
    /* написать свою реализацию здесь */
  }

  /**
   * Вызывается при получении новых сделок инструмента, на который мы смотрим:
   * trades - вектор новых сделок.
   **/
  virtual void trades_feed_update(const std::vector<Trade>& trades) {
    /* написать свою реализацию здесь */
  }

  /**
   * Вызывается, когда симуляция закончила обрабатывать все изменения,
   * соответствующие одному биржевому событию.
   **/
  virtual void process_event_end() {
    /* написать свою реализацию здесь */
  }

  /**
   * Вызывается при получении отчета о сделке с участием вашего ордера.
   **/
  virtual void execution_report_update(const ExecutionReportSnapshot* snapshot) {
    /* написать свою реализацию здесь */
  }
```
   
Перед вами класс **UserStrategy**. Здесь объявлено 6 виртуальных функций, которые вы можете реализовать в своей стратегии. Рассмотрим их подробнее.

При торговле на бирже постоянно происходят какие-то события в стаканах инструментов. Для информирования нашей стратегии о произошедших изменениях биржа посылает нам актуальную версию текущего состояния стакана. Функции  **book_trade_update** и **book_feed_update** принимают на вход ссылку на элемент типа **OrderBook**, который и является новой версией стакана. Отличаются же эти функции тем, с каким инструментом они работают: trade -- стакан инструмента на котором стратегия торгует, feed - для инструмента, на который мы только смотрим.

Важное замечание по поводу апдейтов стакана: в ParticipantStrategy есть поля book_trade и book_trade_snapshot (и соответствующие поля для feed) -- в них содержится указатель на актуальный стакан и умный указатель на структуру, содержащую этот стакан. Важно понимать, что если в вашей стратегии вы явно не сохранитет аналог book_trade_snapshot, то при следущюем trade_book_update book_trade и book_trade_snapshot обновятся, и предыдущий актуальный стакан будет недоступен (потому что на предыдущий стакан останется 0 активных ссылок). Другое замечание заключается в том, что book_trade содержит указатель на копию того стакана, с которым работает симулятор, поэтому эта копия никогда не меняется.

Помимо изменений стакана полезной информацией являются совершенные сделки. Для того, чтобы получать и обрабатывать эти изменения, вам предоставлены функции **trades_trade_update** и **trades_feed_update**, которые принимают в качестве аргумента вектор элементов класса **Trade**, который хранит в себе информацию об одной совершённой сделке. Заметьте, что для каждой совершенной сделки информация о ней приходит **ровно один раз**. Различие этих функций абсолютно такое же, как и у book-функций: trades_trade_update позволяет обрабатывать сделки инструмента на котором идет торговля, feed - функция для сигнального инструмента (то есть того, на который стратегия только смотрит).

В общем-то, реализовывать логику стратегии вплоть до постановки и удаления заявок можно во всех описанных выше методах. Однако следует понимать, что биржа шлет информацию лимитированными **пакетами**, и при этом любое событие выше может не соответствовать реальному окончанию обработки биржей (и нами) какого-то события. Например, если в результате постановки заявки случилось много сделок, и не все они влезли в один пакет, то будет прислано два (или более) подряд апдейта со сделками. При этом об окончании сообщений о конкретном событии нас информирует вызов метода  **process_event_end**. Ее вызов означает, что всю возможную информацию о некотором биржевом событии вы уже получили.

Функция **execution_report_update** предназначена для того, чтобы получать информацию о совершенных сделках с участием наших заявок.
