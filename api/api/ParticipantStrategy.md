#ParticipantStrategy

Описание класса ParticipantStrategy (объявлен в include/simulator/strategy/participant_strategy_layer.h)
----------------

Стратегии наследуются от класса ParticipantStrategy, который служит прослойкой между симуляционным ядром и стратегией. Он обеспечивает обработку входящих сигналов от симуляции (апдейтов стаканов, сделок, сообщений о концах биржевых событий) и передачу в симуляцию сообщений о желаемых действий стратегии (постановка, снятие и перемещение заявок). Помимо реализации методов для описанных выше действий, класс также предоставляет некоторые вспомогательные методы для удобства работы.

В конструктор стратегии передается конфиг, в котором могут быть параметры, необходимые для работы стратегии, и которые могут перебираться в системе стратегии для подбора оптимального набора. Подробнее по параметры и их перебор можно почитать тут.

#Основные неприватные поля класса:

- const OrderBookL2* book_trade;
Стакан инструмента, на котором торгуем.

- const OrderBookL2* book_feed;
Стакан инструмента, на который только смотрим.

- ContestBookInfo trade_book_info;
Стуктура-аггрегатор основной информации о стакане, на котором торгуем.

- ContestBookInfo feed_book_info;
Стуктура-аггрегатор основной информации о стакане, на который смотрим.

#Методы, реализующие доставку апдейтов от симуляции к стратегии:

- virtual void book_trade_update(const OrderBook& order_book);
Функция, которую должен реализовать участник в классе UserStrategy, которая вызывается при получении нового стакана инструмента, на котором мы торгуем: order_book - новый стакан

- virtual void book_feed_update(const OrderBook& order_book);
Функция, которую должен реализовать участник в классе UserStrategy, которая вызывается при получении нового стакана инструмента, на который мы смотрим: order_book - новый стакан

- virtual void trades_trade_update(const std::vector<Trade>& trades);
Функция, которую должен реализовать участник в классе UserStrategy, которая вызывается при получении новой порции сделок инструмента, на котором мы торгуем. trades - вектор новых сделок

- virtual void trades_feed_update(const std::vector<Trade>& trades);
Функция, которую должен реализовать участник в классе UserStrategy, которая вызывается при получении новой порции сделок инструмента, на который мы смотрим. trades - вектор новых сделок

- virtual void process_event_end();
Функция, которую должен реализовать участник в классе UserStrategy. Вызывается, когда симуляция закончила обрабатывать все изменения, соответствующие одному биржевому событию.

- virtual void execution_report_update(const ExecutionReportSnapshot* snapshot);
Функция, которую должен реализовать участник в классе UserStrategy, которая вызывается при получении отчета о сделке с участием вашего ордера

#Методы для постановки, снятия и перемещения заявок:

bool add_order(Price price, Amount amount, Dir dir, Amount implied_amount = 0);
Функция, выставляющая наш заявку:
price - цена, по которой заявка будет выставлена
amount - размер заявки
dir - направление (BID = 0 - покупка, ASK = 1 - продажа)
implied_amount - ожидаемое реализованное количество (рекомендуется использовать значение 0)

- bool add_ioc_order(Price price, Amount amount, Dir dir);
Функция, выставляющая нашу заявку по принципу immediate-or-close:
price - цена, по которой заявка будет выставлена
amount - размер заявки
dir - направление (BID = 0 - покупка, ASK = 1 - продажа)
ожидаемый реализованный объем совпадает с объемом заявки

- bool add_ioc_order(Price price, Amount amount, Dir dir, Amount implied_amount);
Функция, выставляющая нашу заявку по принципу immediate-or-close:
price - цена, по которой заявка будет выставлена
amount - размер заявки
dir - направление (BID = 0 - покупка, ASK = 1 - продажа)
implied_amount ожидаемое реализованное количество (рекомендуется использовать значение amount)

- void delete_order(Order* order);
Функция, снимающая наш ордер с торгов:
order - ордер, который мы хотим снять

#Вспомогательные методы:

- Amount total_amount();
Функция, возвращающая нашу текущую позу.

- Amount executed_amount();
Функция, возвращающая нашу текущую позу без учета implied - заявок.

- Amount total_active_amount(Dir dir);
Функция для подсчета текущего суммарного размера выставленных ордеров по фиксированному направлению: dir - направление ордеров

- Amount count_active_orders(Dir dir);
Функция, возвращающая количество активных ордеров по фиксированному направлению: dir - направление ордеров

- Price best_price (Dir dir, bool is_book_trade = true);
Функция, возвращающая лучшую цену по данному направлению:
dir - направление
is_book_trade = true - торговый стакан, is_book_trade = false - сигнальный стакан

- Price get_saldo();
Функция, возвращающая текущее сальдо (текущий баланс без учета позы)

- Price get_current_result();
Функция, возвращающая текущий результат (заработок)

- bool cmp(Price a, Price b, Dir dir);
Функция сравнения двух цен по фиксированному направлению

- tm get_local_time_tm();
Метод, возвращающий локальное время типа tm c точностью до секунды.
